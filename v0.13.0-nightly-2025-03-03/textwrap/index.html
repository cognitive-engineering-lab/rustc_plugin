<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The textwrap library provides functions for word wrapping and indenting text."><title>textwrap - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="textwrap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (f4a216d28 2025-03-02)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-d8ac8691.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-a7bf3405.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../textwrap/index.html">textwrap</a><span class="version">0.16.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#wrapping-text" title="Wrapping Text">Wrapping Text</a><ul><li><a href="#wrapping-strings-at-compile-time" title="Wrapping Strings at Compile Time">Wrapping Strings at Compile Time</a></li><li><a href="#displayed-width-vs-byte-size" title="Displayed Width vs Byte Size">Displayed Width vs Byte Size</a></li></ul></li><li><a href="#indentation-and-dedentation" title="Indentation and Dedentation">Indentation and Dedentation</a></li><li><a href="#cargo-features" title="Cargo Features">Cargo Features</a><ul><li><a href="#default-features" title="Default Features">Default Features</a></li><li><a href="#optional-features" title="Optional Features">Optional Features</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>textwrap</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/textwrap/lib.rs.html#1-235">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The textwrap library provides functions for word wrapping and
indenting text.</p>
<h2 id="wrapping-text"><a class="doc-anchor" href="#wrapping-text">§</a>Wrapping Text</h2>
<p>Wrapping text can be very useful in command-line programs where
you want to format dynamic output nicely so it looks good in a
terminal. A quick example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"textwrap: a small library for wrapping text."</span>;
<span class="macro">assert_eq!</span>(textwrap::wrap(text, <span class="number">18</span>),
           <span class="macro">vec!</span>[<span class="string">"textwrap: a"</span>,
                <span class="string">"small library for"</span>,
                <span class="string">"wrapping text."</span>]);</code></pre></div>
<p>The <a href="fn.wrap.html" title="fn textwrap::wrap"><code>wrap()</code></a> function returns the individual lines, use
<a href="fn.fill.html" title="fn textwrap::fill"><code>fill()</code></a> is you want the lines joined with <code>'\n'</code> to form a
<code>String</code>.</p>
<p>If you enable the <code>hyphenation</code> Cargo feature, you can get
automatic hyphenation for a number of languages:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">"hyphenation"</span>)] </span>{
<span class="kw">use </span>hyphenation::{Language, Load, Standard};
<span class="kw">use </span>textwrap::{wrap, Options, WordSplitter};

<span class="kw">let </span>text = <span class="string">"textwrap: a small library for wrapping text."</span>;
<span class="kw">let </span>dictionary = Standard::from_embedded(Language::EnglishUS).unwrap();
<span class="kw">let </span>options = Options::new(<span class="number">18</span>).word_splitter(WordSplitter::Hyphenation(dictionary));
<span class="macro">assert_eq!</span>(wrap(text, <span class="kw-2">&amp;</span>options),
           <span class="macro">vec!</span>[<span class="string">"textwrap: a small"</span>,
                <span class="string">"library for wrap-"</span>,
                <span class="string">"ping text."</span>]);
}</code></pre></div>
<p>See also the <a href="fn.unfill.html" title="fn textwrap::unfill"><code>unfill()</code></a> and <a href="fn.refill.html" title="fn textwrap::refill"><code>refill()</code></a> functions which allow
you to manipulate already wrapped text.</p>
<h3 id="wrapping-strings-at-compile-time"><a class="doc-anchor" href="#wrapping-strings-at-compile-time">§</a>Wrapping Strings at Compile Time</h3>
<p>If your strings are known at compile time, please take a look at
the procedural macros from the <a href="https://docs.rs/textwrap-macros/">textwrap-macros</a> crate.</p>
<h3 id="displayed-width-vs-byte-size"><a class="doc-anchor" href="#displayed-width-vs-byte-size">§</a>Displayed Width vs Byte Size</h3>
<p>To word wrap text, one must know the width of each word so one can
know when to break lines. This library will by default measure the
width of text using the <em>displayed width</em>, not the size in bytes.
The <code>unicode-width</code> Cargo feature controls this.</p>
<p>This is important for non-ASCII text. ASCII characters such as <code>a</code>
and <code>!</code> are simple and take up one column each. This means that
the displayed width is equal to the string length in bytes.
However, non-ASCII characters and symbols take up more than one
byte when UTF-8 encoded: <code>é</code> is <code>0xc3 0xa9</code> (two bytes) and <code>⚙</code> is
<code>0xe2 0x9a 0x99</code> (three bytes) in UTF-8, respectively.</p>
<p>This is why we take care to use the displayed width instead of the
byte count when computing line lengths. All functions in this
library handle Unicode characters like this when the
<code>unicode-width</code> Cargo feature is enabled (it is enabled by
default).</p>
<h2 id="indentation-and-dedentation"><a class="doc-anchor" href="#indentation-and-dedentation">§</a>Indentation and Dedentation</h2>
<p>The textwrap library also offers functions for adding a prefix to
every line of a string and to remove leading whitespace. As an
example, <a href="fn.indent.html" title="fn textwrap::indent"><code>indent()</code></a> allows you to turn lines of text into a
bullet list:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>before = <span class="string">"\
foo
bar
baz
"</span>;
<span class="kw">let </span>after = <span class="string">"\
* foo
* bar
* baz
"</span>;
<span class="macro">assert_eq!</span>(textwrap::indent(before, <span class="string">"* "</span>), after);</code></pre></div>
<p>Removing leading whitespace is done with <a href="fn.dedent.html" title="fn textwrap::dedent"><code>dedent()</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>before = <span class="string">"
    Some
      indented
        text
"</span>;
<span class="kw">let </span>after = <span class="string">"
Some
  indented
    text
"</span>;
<span class="macro">assert_eq!</span>(textwrap::dedent(before), after);</code></pre></div>
<h2 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo Features</h2>
<p>The textwrap library can be slimmed down as needed via a number of
Cargo features. This means you only pay for the features you
actually use.</p>
<p>The full dependency graph, where dashed lines indicate optional
dependencies, is shown below:</p>
<img src="https://raw.githubusercontent.com/mgeisler/textwrap/master/images/textwrap-0.16.2.svg">
<h3 id="default-features"><a class="doc-anchor" href="#default-features">§</a>Default Features</h3>
<p>These features are enabled by default:</p>
<ul>
<li>
<p><code>unicode-linebreak</code>: enables finding words using the
<a href="https://docs.rs/unicode-linebreak/">unicode-linebreak</a> crate, which implements the line breaking
algorithm described in <a href="https://www.unicode.org/reports/tr14/">Unicode Standard Annex
#14</a>.</p>
<p>This feature can be disabled if you are happy to find words
separated by ASCII space characters only. People wrapping text
with emojis or East-Asian characters will want most likely want
to enable this feature. See <a href="enum.WordSeparator.html" title="enum textwrap::WordSeparator"><code>WordSeparator</code></a> for details.</p>
</li>
<li>
<p><code>unicode-width</code>: enables correct width computation of non-ASCII
characters via the <a href="https://docs.rs/unicode-width/">unicode-width</a> crate. Without this feature,
every <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a> is 1 column wide, except for emojis which are 2
columns wide. See <a href="core/fn.display_width.html" title="fn textwrap::core::display_width"><code>core::display_width()</code></a> for details.</p>
<p>This feature can be disabled if you only need to wrap ASCII
text, or if the functions in <a href="core/index.html" title="mod textwrap::core"><code>core</code></a> are used directly with
<a href="core/trait.Fragment.html" title="trait textwrap::core::Fragment"><code>core::Fragment</code></a>s for which the widths have been computed in
other ways.</p>
</li>
<li>
<p><code>smawk</code>: enables linear-time wrapping of the whole paragraph via
the <a href="https://docs.rs/smawk/">smawk</a> crate. See <a href="wrap_algorithms/fn.wrap_optimal_fit.html" title="fn textwrap::wrap_algorithms::wrap_optimal_fit"><code>wrap_algorithms::wrap_optimal_fit()</code></a>
for details on the optimal-fit algorithm.</p>
<p>This feature can be disabled if you only ever intend to use
<a href="wrap_algorithms/fn.wrap_first_fit.html" title="fn textwrap::wrap_algorithms::wrap_first_fit"><code>wrap_algorithms::wrap_first_fit()</code></a>.</p>
</li>
</ul>
<!-- begin binary-sizes -->
<p>With Rust 1.64.0, the size impact of the above features on your
binary is as follows:</p>
<div><table><thead><tr><th style="text-align: left">Configuration</th><th style="text-align: right">Binary Size</th><th style="text-align: right">Delta</th></tr></thead><tbody>
<tr><td style="text-align: left">quick-and-dirty implementation</td><td style="text-align: right">289 KB</td><td style="text-align: right">— KB</td></tr>
<tr><td style="text-align: left">textwrap without default features</td><td style="text-align: right">305 KB</td><td style="text-align: right">16 KB</td></tr>
<tr><td style="text-align: left">textwrap with smawk</td><td style="text-align: right">317 KB</td><td style="text-align: right">28 KB</td></tr>
<tr><td style="text-align: left">textwrap with unicode-width</td><td style="text-align: right">309 KB</td><td style="text-align: right">20 KB</td></tr>
<tr><td style="text-align: left">textwrap with unicode-linebreak</td><td style="text-align: right">342 KB</td><td style="text-align: right">53 KB</td></tr>
</tbody></table>
</div><!-- end binary-sizes -->
<p>The above sizes are the stripped sizes and the binary is compiled
in release mode with this profile:</p>
<div class="example-wrap"><pre class="language-toml"><code>[profile.release]
lto = true
codegen-units = 1</code></pre></div>
<p>See the <a href="https://github.com/mgeisler/textwrap/tree/master/examples/binary-sizes">binary-sizes demo</a> if you want to reproduce these
results.</p>
<h3 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional Features</h3>
<p>These Cargo features enable new functionality:</p>
<ul>
<li>
<p><code>terminal_size</code>: enables automatic detection of the terminal
width via the <a href="https://docs.rs/terminal_size/">terminal_size</a> crate. See
[<code>Options::with_termwidth()</code>] for details.</p>
</li>
<li>
<p><code>hyphenation</code>: enables language-sensitive hyphenation via the
<a href="https://docs.rs/hyphenation/">hyphenation</a> crate. See the <a href="word_splitters/enum.WordSplitter.html" title="enum textwrap::word_splitters::WordSplitter"><code>word_splitters::WordSplitter</code></a>
trait for details.</p>
</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.WordSplitter"><code>pub use word_splitters::<a class="enum" href="word_splitters/enum.WordSplitter.html" title="enum textwrap::word_splitters::WordSplitter">WordSplitter</a>;</code></dt><dt id="reexport.WrapAlgorithm"><code>pub use wrap_algorithms::<a class="enum" href="wrap_algorithms/enum.WrapAlgorithm.html" title="enum textwrap::wrap_algorithms::WrapAlgorithm">WrapAlgorithm</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="core/index.html" title="mod textwrap::core">core</a></dt><dd>Building blocks for advanced wrapping functionality.</dd><dt><a class="mod" href="word_splitters/index.html" title="mod textwrap::word_splitters">word_<wbr>splitters</a></dt><dd>Word splitting functionality.</dd><dt><a class="mod" href="wrap_algorithms/index.html" title="mod textwrap::wrap_algorithms">wrap_<wbr>algorithms</a></dt><dd>Word wrapping algorithms.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Options.html" title="struct textwrap::Options">Options</a></dt><dd>Holds configuration options for wrapping and filling text.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.LineEnding.html" title="enum textwrap::LineEnding">Line<wbr>Ending</a></dt><dd>Supported line endings. Like in the Rust standard library, two line
endings are supported: <code>\r\n</code> and <code>\n</code></dd><dt><a class="enum" href="enum.WordSeparator.html" title="enum textwrap::WordSeparator">Word<wbr>Separator</a></dt><dd>Describes where words occur in a line of text.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.dedent.html" title="fn textwrap::dedent">dedent</a></dt><dd>Removes common leading whitespace from each line.</dd><dt><a class="fn" href="fn.fill.html" title="fn textwrap::fill">fill</a></dt><dd>Fill a line of text at a given width.</dd><dt><a class="fn" href="fn.fill_inplace.html" title="fn textwrap::fill_inplace">fill_<wbr>inplace</a></dt><dd>Fill <code>text</code> in-place without reallocating the input string.</dd><dt><a class="fn" href="fn.indent.html" title="fn textwrap::indent">indent</a></dt><dd>Indent each line by the given prefix.</dd><dt><a class="fn" href="fn.refill.html" title="fn textwrap::refill">refill</a></dt><dd>Refill a paragraph of wrapped text with a new width.</dd><dt><a class="fn" href="fn.unfill.html" title="fn textwrap::unfill">unfill</a></dt><dd>Unpack a paragraph of already-wrapped text.</dd><dt><a class="fn" href="fn.wrap.html" title="fn textwrap::wrap">wrap</a></dt><dd>Wrap a line of text at a given width.</dd><dt><a class="fn" href="fn.wrap_columns.html" title="fn textwrap::wrap_columns">wrap_<wbr>columns</a></dt><dd>Wrap text into columns with a given total width.</dd></dl></section></div></main></body></html>