searchState.loadedDescShard("index_vec", 0, "This crate helps with defining “newtype”-style …\nRepresents a wrapped value convertable to and from a <code>usize</code>.\nThis trait to function in API signatures where <code>Vec&lt;T&gt;</code> or …\nThis is the equivalent of the sealed …\n<code>IndexBox&lt;I, [T]&gt;</code>: An alias for indexed boxed slice.\nA slice that only accepts indices of a specific type. Note …\nA Vec that only accepts indices of a specific type.\nMoves all the elements of <code>other</code> into <code>Self</code>, leaving <code>other</code> …\nReturns an unsafe mutable pointer to the slice’s buffer.\nGet a mutable IndexSlice over this vector. See …\nEquivalent to accessing our <code>raw</code> field mutably, but as a …\nReturns an unsafe pointer to the slice’s buffer.\nReturns the underlying slice.\nGet a the storage as a <code>&amp;[T]</code>\nReturns the underlying slice.\nGet a the storage as a <code>&amp;mut [T]</code>\nGet a IndexSlice over this vector. See <code>as_raw_slice</code> for …\nEquivalent to accessing our <code>raw</code> field, but as a function.\nCall <code>slice::binary_search</code> converting the indices it gives …\nBinary searches this sorted vec with a comparator …\nBinary searches this sorted vec with a key extraction …\nWraps the underlying slice’s <code>chunks</code> iterator with one …\nWraps the underlying slice’s <code>chunks_exact</code> iterator with …\nWraps the underlying slice’s <code>chunks_exact_mut</code> iterator …\nWraps the underlying slice’s <code>chunks_mut</code> iterator with …\nClear our vector. See <code>Vec::clear</code>.\nCopies the elements from <code>src</code> into <code>self</code>.\nForwards to the slice’s <code>contains</code> implementation.\nCopies all elements from <code>src</code> into <code>self</code>, using a memcpy.\nCopies elements from one part of the slice to another part …\nForwards to the <code>Vec::dedup</code> implementation.\nForwards to the <code>Vec::dedup_by</code> implementation.\nForwards to the <code>Vec::dedup_by_key</code> implementation.\nGenerate the boilerplate for a newtyped index struct, for …\nReturn an iterator that removes the items from the …\nSimilar to <code>self.drain(r).enumerate()</code> but with indices of <code>I</code> …\nForwards to the slice’s <code>ends_with</code> implementation.\nAppend all items in the slice to the end of our vector.\nReturn the the first element, if we are not empty.\nReturn the the first element, if we are not empty.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a IdxSlice from its pointer and length.\nCreate a mutable IdxSlice from its pointer and length.\nConstruct a new IdxSlice by wrapping an existing slice.\nConstruct a new mutable IdxSlice by wrapping an existing …\nConstruct an Index from a usize. This is equivalent to …\nConstruct a <code>IndexVec</code> from a <code>Vec&lt;T&gt;</code>.\nGet a ref to the item at the provided index, or None for …\nGet a ref to the item at the provided index, or None for …\nGet a mut ref to the item at the provided index, or None …\nGet a mut ref to the item at the provided index, or None …\nGet the underlying index. This is equivalent to <code>Into&lt;usize&gt;</code>\nA macro similar to the stdlib’s <code>vec![]</code>, but producing an …\nA macro equivalent to the stdlib’s <code>vec![]</code>, but producing …\nGet an interator over all our indices.\nInsert an item at <code>index</code>. See <code>Vec::insert</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the vector into an owned IdxSlice, dropping …\nSimilar to <code>self.into_iter().enumerate()</code> but with indices …\nConverts <code>self</code> into a vector without clones or allocation.\nReturns true if we’re empty.\nGet a iterator over reverences to our values.\nSimilar to <code>self.iter().enumerate()</code> but with indices of <code>I</code> …\nGet a iterator over mut reverences to our values.\nSimilar to <code>self.iter_mut().enumerate()</code> but with indices of …\nReturn the the last element, if we are not empty.\nReturn the index of the last element, or panic.\nReturn the the last element, if we are not empty.\nReturns the length of our slice.\nReturns the length of our slice as an <code>I</code>.\nConstruct a new IdxSlice by wrapping an existing slice.\nConstruct a new IndexVec.\nConstruct a new mutable IdxSlice by wrapping an existing …\nGives the next index that will be assigned when <code>push</code> is …\nPops the last item off, returning it. See <code>Vec::pop</code>.\nSearches for an element in an iterator, returning its …\nPush a new item onto the vector, and return it’s index.\nOur wrapped Vec.\nWraps the underlying slice’s <code>rchunks</code> iterator with one …\nWraps the underlying slice’s <code>rchunks_exact</code> iterator with …\nWraps the underlying slice’s <code>rchunks_exact_mut</code> iterator …\nWraps the underlying slice’s <code>rchunks_mut</code> iterator with …\nRemove the item at <code>index</code>. See <code>Vec::remove</code>.\nReserve capacity for <code>c</code> more elements. See <code>Vec::reserve</code>\nResize ourselves in-place to <code>new_len</code>. See <code>Vec::resize</code>.\nResize ourselves in-place to <code>new_len</code>. See <code>Vec::resize_with</code>.\nForwards to the <code>Vec::retain</code> implementation.\nForwards to the slice’s <code>reverse</code> implementation.\nRotates our data in-place such that the first <code>mid</code> elements …\nRotates our data in-place such that the first …\nSearches for an element in an iterator from the right, …\nWraps the underlying slice’s <code>rsplit</code> iterator with one …\nWraps the underlying slice’s <code>rsplit_mut</code> iterator with …\nWraps the underlying slice’s <code>rsplitn</code> iterator with one …\nWraps the underlying slice’s <code>rsplitn_mut</code> iterator with …\nShrinks the capacity of the vector as much as possible.\nForwards to the slice’s <code>sort</code> implementation.\nForwards to the slice’s <code>sort_by</code> implementation.\nForwards to the slice’s <code>sort_by_cached_key</code> …\nForwards to the slice’s <code>sort_by_key</code> implementation.\nForwards to the slice’s <code>sort_unstable</code> implementation.\nForwards to the slice’s <code>sort_unstable_by</code> implementation.\nForwards to the slice’s <code>sort_unstable_by_key</code> …\nCreates a splicing iterator that replaces the specified …\nWraps the underlying slice’s <code>split</code> iterator with one …\nDivides our slice into two at an index.\nDivides our slice into two at an index.\nReturns the first and all the rest of the elements of the …\nReturns the first and all the rest of the elements of the …\nReturns the last and all the rest of the elements of the …\nReturns the last and all the rest of the elements of the …\nWraps the underlying slice’s <code>split_mut</code> iterator with one …\nSplits the collection into two at the given index. See …\nWraps the underlying slice’s <code>splitn</code> iterator with one …\nWraps the underlying slice’s <code>splitn_mut</code> iterator with …\nForwards to the slice’s <code>starts_with</code> implementation.\nSwaps two elements in our vector.\nRemove the item at <code>index</code> without maintaining order. See …\nSwaps all elements in <code>self</code> with those in <code>other</code>.\nCopies <code>self</code> into a new <code>IndexVec</code>.\nShortens the vector, keeping the first <code>len</code> elements and …\nWraps the underlying slice’s <code>windows</code> iterator with one …\nConstruct an IndexVec that can hold at least <code>capacity</code> …")